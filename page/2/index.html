<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="zjiash的博客">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="zjiash的博客">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="zjiash的博客">
<meta name="twitter:description">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/"/>





  <title>zjiash的博客</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">zjiash的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/02/《深入理解Java虚拟机》之执行引擎/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zjiash">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zjiash的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/02/《深入理解Java虚拟机》之执行引擎/" itemprop="url">
                  《深入理解Java虚拟机》之执行引擎
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-02T15:13:16+08:00">
                2017-03-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/02/《深入理解Java虚拟机》之执行引擎/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/02/《深入理解Java虚拟机》之执行引擎/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="虚拟机和物理机"><a href="#虚拟机和物理机" class="headerlink" title="虚拟机和物理机"></a>虚拟机和物理机</h3><ol>
<li>二者都具有代码执行能力</li>
<li>物理机的执行引擎直接建立在处理器、硬件、指令集和操作系统之上</li>
<li>虚拟机的执行引擎可以自己实现，自己定义指令集和引擎架构，支持不被硬件直接支持的指令格式</li>
</ol>
<h3 id="运行时栈帧结构"><a href="#运行时栈帧结构" class="headerlink" title="运行时栈帧结构"></a>运行时栈帧结构</h3><ol>
<li>每一个栈帧都包含了局部变量表、操作数栈、动态连接、方法返回地址和一些额外的附加消息</li>
<li>编译时，栈帧需要的局部变量表大小、操作数栈深度都已完全确定（方法表的Code属性记录）</li>
<li>方法链中位于栈顶的栈帧才有效，称为当前栈帧，执行引擎运行的所有指令都只针对当前栈帧</li>
<li>局部变量表<ul>
<li>用于存储方法参数和方法内定义的变量</li>
<li>容量以变量槽Slot为最小单位，容量写在Code属性的max_locals数据项中</li>
<li>Slot的大小不定，每个Slot需要能存储包括int、float、reference等类型的数据</li>
<li>虚拟机通过索引定位的方式使用局部变量表</li>
<li>局部变量的Slot可以重用，会有额外副作用，在某些情况下，会导致GC暂时无法回收空间</li>
</ul>
</li>
<li>操作数栈<ul>
<li>后入先出数据结构，最大深度写在Code属性的max_stacks数据项中</li>
<li>通过入栈（push常数和load局部变量）来为字节码指令准备操作数，操作数数据类型必须和字节码指令的序列严格匹配，操作完之后的变量赋值再通过store指令完成</li>
<li>Java虚拟机的解释执行引擎称为基于栈的执行引擎，这里的栈就是操作数栈</li>
</ul>
</li>
<li>动态链接<ul>
<li>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用</li>
<li>Class文件的常量池中存在大量的符合引用，字节码中的方法调用指令就以常量池中指向方法的符合引用作为参数</li>
<li>静态解析和动态连接</li>
</ul>
</li>
<li>方法返回地址</li>
<li>附加信息：完全取决于具体的虚拟机实现</li>
</ol>
<h3 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h3><ol>
<li>方法调用并不等同于方法执行，方法调用阶段的唯一任务是确定被调用的是哪一个方法</li>
<li>五种方法调用字节码指令<ul>
<li>invokestatic：调用静态方法</li>
<li>invokespecial：调用实例构造器方法、私有方法和父类方法</li>
<li>invokevirtual：调用所有的虚方法</li>
<li>invokeinterface：调用接口方法，运行时再确定具体对象</li>
<li>invokedynamic：动态解析调用点限定符所引用的方法</li>
<li>前4条调用指令，分派逻辑固化在JVM内部，而invokedynamic的分派逻辑由用户所设定的引导方法决定</li>
</ul>
</li>
<li>解析（Resolution）：编译阶段就确定下来调用目标的方法调用称为解析<ul>
<li>编译期可知，运行期不可变，主要包括静态方法和私有方法（均不可能重写其他版本）</li>
<li>invokestatic和invokespecial指令调用的方法，类加载的解析阶段即可进行</li>
<li>final方法使用invokevirtual指令来调用，也是解析阶段将符号引用解析为直接引用</li>
<li>静态解析的方法称为非虚方法，其他称为虚方法</li>
</ul>
</li>
<li><p>分派（Dispatch）</p>
<ul>
<li>解析是静态的，不会延迟到运行期完成；分配可以是静态，也可以是动态</li>
<li><p>静态分派：依赖方法的静态类型定位执行版本</p>
<ul>
<li>重载（Overload）的方法通过参数的静态类型判断，使用invokevirtual，编译期间决定</li>
<li>字面量没有静态类型，编译器会选择“更加合适的”版本</li>
<li>解析和分配并不是二选一的排他关系，他们是在不同层次上去筛选、确定目标方法的过程，静态方法会在类加载期就进行解析，静态方法的重载版本选择通过静态分派</li>
</ul>
<pre class="codehilite">
  Human man = new Man();
  man = new Woman();  // 实际类型变化
  // 静态类型变化
  sr.sayHello((Man) man);
  sr.sayHello((Woman) man);
  // Human称为变量的静态类型或外观类型，Man称为变量的实际类型
  // 区别：静态类型的变化仅仅在使用时发生，编译期可知；实际类型运行时才可确定
</pre>
</li>
<li><p>动态分派：重写（Override）相关</p>
<ul>
<li>重写（Override）方法的调用指令都是一样的，但执行的目标方法并不同，依赖invokevirtual指令的多态查找过程（根据操作数栈里面的对象来找，重载应该也是）</li>
</ul>
</li>
<li>单分派和多分派<ul>
<li>方法的接受者和方法参数称为方法的宗量，基于宗量的数量可分为单分派和多分派</li>
<li>静态分配属于多分派，同时考虑接受者和参数的静态类型</li>
<li>动态分派属于单分派，只考虑接收者    </li>
</ul>
</li>
<li>今天的Java语言还是一门静态多分派、动态单分派的语言</li>
<li>动态分派的实现：虚方法表，子类会承袭父类的方法，直接查表即可得</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分派示例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dispatch</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">QQ</span> </span>&#123;&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">_360</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span><span class="params">(QQ args)</span> </span>&#123;</span><br><span class="line">			System.out.println(<span class="string">"father choose qq"</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span><span class="params">(_360 args)</span> </span>&#123;</span><br><span class="line">			System.out.println(<span class="string">"father choose 360"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span><span class="params">(QQ args)</span> </span>&#123;</span><br><span class="line">			System.out.println(<span class="string">"son choose qq"</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span><span class="params">(_360 args)</span> </span>&#123;</span><br><span class="line">			System.out.println(<span class="string">"son choose 360"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Father father = <span class="keyword">new</span> Father();</span><br><span class="line">		Father son = <span class="keyword">new</span> Son();</span><br><span class="line">		father.hardChoice(<span class="keyword">new</span> _360());</span><br><span class="line">		son.hardChoice(<span class="keyword">new</span> QQ());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出为：</span></span><br><span class="line">father choose <span class="number">360</span></span><br><span class="line">son choose qq</span><br></pre></td></tr></table></figure>
<h3 id="动态类型语言支持"><a href="#动态类型语言支持" class="headerlink" title="动态类型语言支持"></a>动态类型语言支持</h3><p>不同类型直接的动态绑定，只要我实现了该方法即可，感觉相当于自己写switch分派，只是它提供了一致机制</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/27/《深入理解Java虚拟机》之类加载机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zjiash">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zjiash的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/27/《深入理解Java虚拟机》之类加载机制/" itemprop="url">
                  《深入理解Java虚拟机》之类加载机制
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-27T14:46:02+08:00">
                2017-02-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/02/27/《深入理解Java虚拟机》之类加载机制/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/02/27/《深入理解Java虚拟机》之类加载机制/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ol>
<li>定义<ul>
<li>虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，称为虚拟机的类加载机制</li>
</ul>
</li>
<li>与其他语言的区别<ul>
<li>编译型语言编译时就进行连接工作</li>
<li>Java语言加载、连接和初始化是在运行期完成的，可以支持动态加载和动态连接</li>
</ul>
</li>
</ol>
<h3 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h3><ol>
<li>类加载的阶段<ul>
<li>加载、连接（包括验证、准备和解析）、初始化</li>
<li>按部就班的顺序，开始是按顺序的，执行可以互相交叉混合</li>
<li><font color="red">注意：加载阶段和类加载的区别（前者是后者的一个阶段）</font></li>
</ul>
</li>
<li>何时开始？<ul>
<li>何时开始加载，虚拟机并没有强制约束</li>
<li>不过对于初始化阶段，规范规定了有且只有下面5种情况必须立即对类进行初始化，遇到下面5种情况，如果类没有进行初始化，需要先触发其初始化<ul>
<li>遇到new、getstatic、putstatic或invokestatic这4条字节码指令时</li>
<li>使用java.lang.reflect包的方法对类进行反射调用时</li>
<li>当初始化一个类的时候，发现其父类还没有进行过初始化，需要先初始化父类</li>
<li>当虚拟机启动时，用户需要指定一个要执行的主类，虚拟机需要先初始化主类</li>
<li>当使用JDK 1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果是REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄对应的类没有进行初始化</li>
</ul>
</li>
<li><font color="red">注意：限定语是“有且只有”</font>，这5种行为称为对一个类的主动引用，其他所有引用类的方式都不允许触发初始化，称为被动引用</li>
<li>被动引用实例一：通过子类引用父类的静态字段，不会导致子类初始化<ul>
<li>对于静态字段，只有直接定义这个字段的类才会被初始化，因此，通过子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。至于是否触发子类的加载和验证阶段，虚拟机规范并未明确规定</li>
</ul>
</li>
<li>被动引用实例二：通过数组定义来引用类，不会触发此类的初始化<ul>
<li>数组定义不会触发其元素类的初始化过程，虚拟机会封装一个类初始化，数组中应有的属性和方法都实现在这个类</li>
</ul>
</li>
<li>被动引用实例三：常量引用不会触发定义常量的类的初始化<ul>
<li>常量在编译阶段会存入调用类的常量池中（编译阶段采用的常量传播优化），本质上并没有直接引用到定义常量的类</li>
</ul>
</li>
</ul>
</li>
<li>接口也有初始化过程，与类的区别：<ul>
<li>接口中不能使用<code>static{}</code>语句块，但依然会生成类构造器<code>&lt;clinit&gt;()</code>，用于初始化接口定义的成员变量</li>
<li>接口变量会自动使用public static final关键字来修饰，方法会使用public关键字来修饰</li>
<li>接口初始化时，并不要求其父接口全部都完成初始化，只有在真正使用父接口的时候（引用接口中定义的常量）才会初始化</li>
<li>接口中常量和类中不一致？</li>
</ul>
</li>
</ol>
<h3 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h3><ol>
<li>加载<ul>
<li>加载阶段要完成的3件事：<ul>
<li>通过类的全限定名来获取定义该类的二进制字节流</li>
<li>将该字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</li>
</ul>
</li>
<li>可以从各种渠道获取二进制字节流，比如文件、网络、数据库、运行时计算等，这个阶段是开发人员可控性最强的，系统会提供引导类加载器，用户也可以自定义</li>
<li>对于数组，情况有所不同，数组类本身不通过加载器创建，它由JVM直接创建</li>
<li>方法区中的数据结构规范并未规定，由虚拟机实现自行定义</li>
</ul>
</li>
<li>验证<ul>
<li>验证字节流中的信息符合当前虚拟机的要求</li>
<li>安全性考虑：字节流的来源太多了，编译器并不能挡掉所有威胁</li>
<li>加载未完成时，验证即可开始，但是开始时间还是有序的</li>
<li>4个阶段的验证动作<ul>
<li>文件格式验证：是否符合Class文件格式？比如魔数、版本号、常量类型、常量索引等</li>
<li>元数据验证：语义是否符合Java语言规范？比如是否有父类，是否继承了不被允许继承的类</li>
<li>字节码验证：数据流和控制流分析，比如操作码和操作数个数类型是否匹配，跳转地址是否合法，类型转换是否合法（通过StackMapTable检查）</li>
<li>符合引用验证：在连接的第三个阶段解析中发生，符号引用是否合法</li>
</ul>
</li>
</ul>
</li>
<li>准备<ul>
<li>为类变量分配内存并设置类变量初始值，只包括类变量，内存在方法区分配</li>
<li>这里的初始值通常是数据类型的零值，真正的赋值在类构造器中发生（初始化），如果是常量，初始值就是真实值</li>
</ul>
</li>
<li>解析<ul>
<li>将常量池内的符号引用替换为直接引用的过程</li>
<li>符号引用：字面量描述的引用目标，无歧义定位，引用的目标不一定已经加载到内存，不同虚拟机符号引用必须一致，Class文件格式中有规定</li>
<li>直接引用：可以是直接指向目标的指针、相对偏移量或间接定位目标的句柄，不同虚拟机直接引用一般不会相同</li>
<li>16个字节码指令要求先解析，除了invokedynamic外，虚拟机可以缓存第一次的解析结果</li>
</ul>
</li>
<li>初始化<ul>
<li>真正开始执行类中定义的Java程序代码</li>
<li>类构造器<code>&lt;clinit&gt;()</code><ul>
<li>编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并生成，按顺序</li>
<li>不需要显示调用父类构造器，虚拟机自己保证</li>
<li>父类定义的静态语句块要优先于子类的变量赋值操作</li>
<li>类构造器并非必须，如果没有类变量和语句块，可以不生成构造器</li>
<li>接口没有语句块，执行接口的<code>&lt;clinit&gt;()</code>不需要先执行父接口的<code>&lt;clinit&gt;()</code>方法</li>
<li>虚拟机会保证类构造器方法只执行一次，其他线程需要等待</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><ol>
<li>实现通过一个全限定名来获取描述此类的二进制字节流动作的代码模块称为“类加载器”</li>
<li>类相等需要加载他们的加载器是同一个加载器</li>
<li>双亲委派模型<ul>
<li>除了启动类加载器，其他加载器都有自己的父类加载器（通过组合而非继承实现）</li>
<li>工作过程：收到加载请求，会先交给自己的父类加载器，只有父类反馈找不到的时候，才自己加载</li>
<li>好处：同一个类肯定会被同一个加载器加载，不会出现不相等的情况</li>
</ul>
</li>
<li>破坏双亲委派模型<ul>
<li>并非强制约束，而是Java设计者推荐给开发者的类加载器实现方式</li>
<li>第一次：提出时与原有实现不兼容，不提倡复写<code>loadClass()</code>方法，而是增加<code>findClass()</code>方法实现自己的加载逻辑</li>
<li>第二次：基础类调用用户代码，比如启动类加载器加载的类需要对资源进行集中管理，需要引入线程上下文类加载器</li>
<li>第三次：追求程序动态性，比如代码热替换</li>
</ul>
</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/20/《深入理解Java虚拟机》之类文件结构/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zjiash">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zjiash的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/20/《深入理解Java虚拟机》之类文件结构/" itemprop="url">
                  《深入理解Java虚拟机》之类文件结构
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-20T11:32:39+08:00">
                2017-02-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/02/20/《深入理解Java虚拟机》之类文件结构/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/02/20/《深入理解Java虚拟机》之类文件结构/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h2><h3 id="无关性基石"><a href="#无关性基石" class="headerlink" title="无关性基石"></a>无关性基石</h3><ol>
<li>平台无关性<ul>
<li>在应用层面上，由虚拟机提供商发布可运行在各种不同平台上的虚拟机</li>
<li>所有平台都统一使用相同的程序存储格式</li>
</ul>
</li>
<li>语言无关性<ul>
<li>任一功能性语言都可以表示为一个能被Java虚拟机所接受的有效的Class文件</li>
<li>虚拟机不和包括Java在内的任何语言绑定，只和“Class文件”这种特定的二进制文件格式关联</li>
<li>Class文件包含了虚拟机指令集和符号表以及若干其他辅助信息</li>
<li>Clojure、JRuby、Groovy、Scala等通过各种的编译器都能产生Class文件</li>
</ul>
</li>
</ol>
<h3 id="Class类文件结构"><a href="#Class类文件结构" class="headerlink" title="Class类文件结构"></a>Class类文件结构</h3><ol>
<li>任何一个Class文件都对应唯一一个类或接口的定义，反过来不一定成立，并非一定要以文件形式存在，单需要满足文件格式</li>
<li>Class文件是一组以8位字节为基础单位的二进制流，各数据项严格按照顺序紧密排列，中间没有任何分隔符，如需要存储超过8位字节的数据项，会分成多个8位字节进行存储</li>
<li>Class文件采用伪结构体来存储数据，只有无符号数和表两种数据类型<ul>
<li>无符号数属于基本数据类型，包括u1、u2、u4、u8，分别表示1、2、4、8个字节的无符号数，用来描述数字、索引引用、数量值或者UTF8编码的字符串值</li>
<li>表是由多个无符号数或者其他表构成的复合数据类型</li>
<li>当同一类型但数量不定的多个数据连续出现时，使用前置容器计数来表示这一集合</li>
</ul>
</li>
<li>具体数据格式（按顺序）<ul>
<li>魔数和版本号<ul>
<li>确定文件是否能被虚拟机接受</li>
</ul>
</li>
<li>常量池<ul>
<li>Class文件中的资源仓库，第一个表类型数据项目</li>
<li>索引从1开始，下标0用于特殊用途</li>
<li>存储两大类常量：字面量和符合引用</li>
<li>符号引用包括：类和接口的全限定名、字段的名称和描述符、方法的名称和描述符</li>
<li>和C/C++不同，Java编译不包括连接，虚拟机加载Class文件时动态连接，因此Class文件不需要保持最终的内存布局信息</li>
<li>常量池中每一项都是一个表，常量可以指向另一个常量</li>
</ul>
</li>
</ul>
<ul>
<li>访问标志<ul>
<li>类文件表示类还是接口、是否public、是否abstract等</li>
</ul>
</li>
<li>类索引和父类索引<ul>
<li>各一个u2类型数据，指向常量池中的CONSTANT_Class_info类描述符常量</li>
</ul>
</li>
<li>接口索引集合<ul>
<li>集合类型，如果长度为0，后面的索引表不占用任何字节</li>
</ul>
</li>
<li>字段表集合<ul>
<li>字段access_flags：类变量还是示例标量、作用域、可变性等</li>
<li>简单名称：比如<code>m</code></li>
<li>描述符：描述字段的数据类型，比如<code>java.lang.String[][]</code>记录为<code>[[Ljava/lang/String</code></li>
<li>属性集合：比如常量字段会带有ConstantValue属性</li>
</ul>
</li>
<li>方法表集合<ul>
<li>结构和字段类似</li>
<li>描述符：<code>Void inc()</code>描述符为<code>()V</code>，<code>java.lang.String toString()</code>描述符为<code>()Ljava.lang.String</code></li>
<li>属性：Code属性</li>
<li>可能出现编译器自动添加的方法，比如类构造器<code>&lt;clinit&gt;</code>和实例构造器<code>&lt;init&gt;</code></li>
<li><font color="red">语言层面Java不允许仅仅依靠返回值不同来Overload一个已有方法，但是如果两个方法有相同的签名（只包括方法名称、参数顺序和类型），只是返回值不同，可以合法共存于同一个Class文件</font></li>
<li>方法的重写(Override)和重载(Overload)是Java多态性的不同表现，Override是父类与子类之间多态性的一种表现，而Overload是一个类中多态性的一种表现</li>
</ul>
</li>
<li>属性表集合<ul>
<li>包括：Code属性、Exception属性、LineNumberTable属性、LocalVariableTable属性、ConstantValue属性等，字段表里面静态变量可以带上ConstantValue属性</li>
<li>Code属性包括异常处理代码，1.4.2之后，finally语句通过冗余来实现，每个分支后面都跟一个</li>
<li>Exception属性记录可能抛出的异常，方法描述时throws后面列举的异常</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="字节码指令"><a href="#字节码指令" class="headerlink" title="字节码指令"></a>字节码指令</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><ol>
<li>Java虚拟机的指令由一个字节长度、代表着某种特定操作含义的数字（操作码Opcode）以及跟随其后的零到多个代表此操作所需参数（操作数Operands）而构成</li>
<li>Java虚拟机采用面向操作数栈而不是寄存器的架构，所以大多数的指令都不包含操作数，只有一个操作码</li>
</ol>
<h4 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h4><ol>
<li>字节码和数据类型<ul>
<li>指令包含操作数所对应的类型，比如iload和fload分别表示加载int和float的数据到操作数栈中，尽管可能是同一段代码，但是Class文件中必须拥有各自独立的操作码</li>
<li>然而，并非每种类型都需要特殊的配套指令（操作码只有一个字节），必要时需要进行类型转换，比如没有byteLoad指令，编译器在编译或运行期会转换成iload来实现</li>
</ul>
</li>
<li>指令分类<ul>
<li>加载和存储指令：iload、istore</li>
<li>运算指令：iadd、isub、iand</li>
<li>类型转换指令：i2f</li>
<li>对象创建和访问指令：new、getfield、getstatic、arraylength</li>
<li>操作数栈管理指令：pop、dup、swap</li>
<li>控制转移指令：ifeq、tableswitch、goto、ret</li>
<li>方法调用和返回指令：invokeinterface、invoke*、ireturn</li>
<li>异常处理指令：athrow</li>
<li>同步指令：monitorenter、monitorexit</li>
</ul>
</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/09/《深入理解Java虚拟机》之内存管理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zjiash">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zjiash的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/09/《深入理解Java虚拟机》之内存管理/" itemprop="url">
                  《深入理解Java虚拟机》之内存管理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-09T16:03:13+08:00">
                2017-02-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/02/09/《深入理解Java虚拟机》之内存管理/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/02/09/《深入理解Java虚拟机》之内存管理/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ol>
<li>哪些内存需要回收？<ul>
<li>程序计数器、虚拟机栈、本地方法栈不需要回收，方法结束或线程结束时，内存自然就回收了</li>
<li>Java堆和方法区需要回收，这部分内存的分配和回收都是动态的，也是GC所关注的</li>
</ul>
</li>
<li>什么时候回收？<ul>
<li>“死去”的对象</li>
</ul>
</li>
<li>如何回收？<ul>
<li>各种垃圾收集器</li>
</ul>
</li>
</ol>
<h3 id="如何判断对象已死"><a href="#如何判断对象已死" class="headerlink" title="如何判断对象已死"></a>如何判断对象已死</h3><h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h4><ol>
<li>思路：给对象添加一个引用计数器，计数为0即表示对象已死</li>
<li>问题：很难解决循环引用的问题</li>
<li>伪代码：参考自<a href="http://www.jianshu.com/p/1d5fa7f6035c" target="_blank" rel="external">http://www.jianshu.com/p/1d5fa7f6035c</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">New(): <span class="comment">//分配内存</span></span><br><span class="line">    ref &lt;- allocate()</span><br><span class="line">    <span class="keyword">if</span> ref == <span class="keyword">null</span></span><br><span class="line">        error <span class="string">"Out of memory"</span></span><br><span class="line">    rc(ref) &lt;- <span class="number">0</span>  <span class="comment">//将ref的引用计数(reference counting)设置为0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function">ref</span><br><span class="line"></span><br><span class="line">atomic <span class="title">Write</span><span class="params">(dest, ref)</span> <span class="comment">//更新对象的引用</span></span><br><span class="line">    <span class="title">addReference</span><span class="params">(ref)</span></span><br><span class="line">    <span class="title">deleteReference</span><span class="params">(dest)</span></span><br><span class="line">    dest &lt;- ref</span><br><span class="line"></span><br><span class="line"><span class="title">addReference</span><span class="params">(ref)</span>:</span><br><span class="line">    <span class="keyword">if</span> ref !</span>= <span class="function"><span class="keyword">null</span></span><br><span class="line">        <span class="title">rc</span><span class="params">(ref)</span> &lt;- <span class="title">rc</span><span class="params">(ref)</span>+1</span><br><span class="line"></span><br><span class="line"><span class="title">deleteReference</span><span class="params">(ref)</span>:</span><br><span class="line">    <span class="keyword">if</span> ref !</span>= <span class="function"><span class="keyword">null</span></span><br><span class="line">        <span class="title">rc</span><span class="params">(ref)</span> &lt;- <span class="title">rc</span><span class="params">(ref)</span> -1</span><br><span class="line">        <span class="keyword">if</span> <span class="title">rc</span><span class="params">(ref)</span> </span>== <span class="number">0</span> <span class="comment">//如果当前ref的引用计数为0，则表明其将要被回收</span></span><br><span class="line">            <span class="function"><span class="keyword">for</span> each fld in <span class="title">Pointers</span><span class="params">(ref)</span></span><br><span class="line">                <span class="title">deleteReference</span><span class="params">(*fld)</span></span><br><span class="line">            <span class="title">free</span><span class="params">(ref)</span> <span class="comment">//释放ref指向的内存空间</span></span></span><br></pre></td></tr></table></figure>
<h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><ol>
<li>思路：通过一系列称为”GC Roots”的对象作为起始点，从这些节点开始向下搜索，不可达的节点已死</li>
<li>GC Roots对象包括：<ul>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>虚拟机栈（栈帧中的本地变量）中引用的对象</li>
<li>本地方法栈中JNI（Native方法）引用的对象</li>
</ul>
</li>
<li>Java中引用的分类：强引用、软引用、弱引用、虚引用，强度依次逐渐减弱</li>
<li>不可达是否意味真的已死？<ul>
<li>真正宣告死亡需要标记两次：不可达，<code>finalize()</code>方法（只会执行一次）</li>
<li>如果有<code>finalize()</code>方法且未执行，方法F-Queue队列，有单独的线程去触发该方法，但并不承诺会等待运行结束</li>
<li>不建议使用<code>finalize()</code>方法，使用try-finally机制</li>
</ul>
</li>
</ol>
<h4 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h4><ol>
<li>回收的内容：废弃的常量和无用的类</li>
<li>性价比比较低，条件苛刻</li>
</ol>
<h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><h4 id="标记清除（Mark-Sweep）算法"><a href="#标记清除（Mark-Sweep）算法" class="headerlink" title="标记清除（Mark-Sweep）算法"></a>标记清除（Mark-Sweep）算法</h4><ul>
<li>思路：两阶段，先标记，再统一回收</li>
<li>问题：效率低，产生大量不连续的内存碎片</li>
</ul>
<h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><ul>
<li>思路：两块内存，用一块空一块，交替复制到空的那块内存</li>
<li>问题：尽管简单高效，但是内存利用率太低了</li>
<li>适合新生代</li>
</ul>
<h4 id="标记整理（Mark-Compact）算法"><a href="#标记整理（Mark-Compact）算法" class="headerlink" title="标记整理（Mark-Compact）算法"></a>标记整理（Mark-Compact）算法</h4><ul>
<li>思路：先标记，后整理存货对象（都像一端移动）</li>
<li>适合老年代</li>
</ul>
<h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><ul>
<li>内存划分为新生代和老年代</li>
<li>新生代：每次收集有大批对象死去，少数存活，选用复制算法</li>
<li>老年代：对象存活率较高且没有额外担保，使用标记清除或标记整理算法</li>
</ul>
<p><img src="http://o7b0ga5fo.bkt.clouddn.com/images/jvm/%E5%86%85%E5%AD%98%E5%88%86%E4%BB%A3.png" width="750" height="390" alt="HotSpot虚拟机内存分代" style="clear: both; display: block; margin:auto; "></p>
<h3 id="HotSpot的算法实现"><a href="#HotSpot的算法实现" class="headerlink" title="HotSpot的算法实现"></a>HotSpot的算法实现</h3><h4 id="如何判断对象已死？"><a href="#如何判断对象已死？" class="headerlink" title="如何判断对象已死？"></a>如何判断对象已死？</h4><ul>
<li>采用可达性分析算法</li>
<li>Stop The World，避免引用关系不断变化</li>
<li>问题一：如何快速确定”GC Roots”？<ul>
<li>HotSpot使用的是准确式GC，不需要检查所有位置，虚拟机有办法直接得知哪些地方存放着对象引用，使用一组称为OopMap的数据结构来达到这个目的</li>
<li>在类加载完成的时候，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，在JIT编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用</li>
</ul>
</li>
<li>问题二：如何进入GC？<ul>
<li>不可能为每条导致引用关系变化的指令都生成OopMap，也不需要每天指令都进入GC</li>
<li>安全点：只有特点的位置才能停下来执行GC，按照“是否具有让程序长时间执行的特征”来选定，“长时间执行”最明显的特征是指令序列复用，例如方法调用、循环跳转、异常跳转等</li>
<li>多线程的问题：需要所有线程都走到安全点，采用主动式中断，设置标志位，各线程执行时主动轮询，轮询标志的地方和安全点重合，轮询发现为真就自己中断</li>
</ul>
</li>
<li>问题三：如何解决线程处于Sleep/Block状态的问题（无法主动轮询）？<ul>
<li>安全区域：一段代码片段之中，引用关系不会发生变化，在这个区域内的任何地方开始GC都是安全的</li>
<li>线程执行到安全区域时，标示自己进入安全区，这段时间JVM发起GC，就不用管这些线程了；线程离开安全区域时，要检查系统是否已经完成了根节点枚举（或者整个GC），如果未完成需要等待收到可以离开安全区的线索才能继续执行</li>
</ul>
</li>
</ul>
<h4 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h4><ul>
<li>存在多种作用于不同分代的收集器，可搭配使用，没有一种放之四海皆准的完美收集器</li>
</ul>
<p><img src="http://o7b0ga5fo.bkt.clouddn.com/images/jvm/HotSpot%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.png" width="500" height="300" alt="HotSpot虚拟机的垃圾收集器" style="clear: both; display: block; margin:auto; "></p>
<ul>
<li>Serial收集器<ul>
<li>单线程，Stop The World</li>
<li>新生代收集器，采用复制算法</li>
<li>到目前为止，Serial收集器依然是虚拟机运行在Client模式下的默认新生代收集器</li>
</ul>
</li>
<li>ParNew收集器<ul>
<li>Serial收集器的多线程版本，Stop The World</li>
<li>新生代收集器，采用复制算法</li>
<li>除了Serial收集器，目前只有ParNew收集器能和CMS收集器配合工作</li>
</ul>
</li>
<li>Parallel Scavenge收集器<ul>
<li>并行（多线程并行工作，用户线程等待）多线程收集器，采用复制算法，和ParNew类似</li>
<li>专注于吞吐量，吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)</li>
<li>适用于非交互式后台运算</li>
</ul>
</li>
<li>Serial Old收集器<ul>
<li>Serial收集器的老年代版本，单线程，Stop The World</li>
<li>采用标记整理算法</li>
<li>CMS收集器失败时的后备预案</li>
</ul>
</li>
<li>Parallel Old收集器<ul>
<li>Parallel Scavenge收集器的老年代版本，采用标记整理算法</li>
<li>配合Parallel Scavenge收集器使用，出现之前Parallel Scavenge收集器只能配合Serial Old收集器使用，性能不佳</li>
</ul>
</li>
<li>CMS收集器<ul>
<li>Construct Mark Sweep，以获取最短回收停顿时间为目标的收集器</li>
<li>老年代收集器，基于标记清除算法</li>
<li>整个过程分为4步：<ul>
<li>初始标记：标记GC Roots能直接关联的对象</li>
<li>并发标记：GC Roots Tracing的过程</li>
<li>重新标记：修正并发标记期间因用户程序继续运作导致的变动，可并行</li>
<li>并发清除：并发表示可与用户线程同时执行</li>
</ul>
</li>
<li>初始标记和重新标记仍然需要Stop The World，但都远比并发标记的时间短</li>
<li>缺点：<ul>
<li>对CPU资源敏感，当CPU比较少时，占用单独的线程对用户程序影响较大</li>
<li>无法处理浮动垃圾，无法收集同时在运行的用户线程产生的新垃圾，需要预留内存供用户线程使用（无法提供时会提前触发Full GC），无法像其他收集器等到老年代几乎被填满才进行收集</li>
<li>会产生大量内存空间碎片，可能提前触发Full GC</li>
<li>Full GC：Concurrent Model Failure触发，使用后备预案Serial Old收集器</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="http://o7b0ga5fo.bkt.clouddn.com/images/jvm/CMS%E6%94%B6%E9%9B%86%E5%99%A8%E8%BF%90%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.png" width="874" height="184" alt="CMS收集器运行示意图" style="clear: both; display: block; margin:auto; "></p>
<ul>
<li><p>G1收集器</p>
<ul>
<li>在未来取代CMS收集器，特点：<ul>
<li>并发和并行：缩短Stop The World时间</li>
<li>分代收集：不需要其他收集器配合</li>
<li>空间整合：整体上来是基于标记整理算法，局部来看是基于复制算法</li>
<li>可预测的停顿：能建立可预测的停顿时间模型，M毫秒的时间片段内，垃圾收集消耗的时间不超过N毫秒</li>
</ul>
</li>
<li><p>G1收集器内存布局与其他收集器区别很大</p>
<ul>
<li>多个大小相等的独立区域Region</li>
<li>保留新生代和老年代的概念，但不再是物理隔离的了，都是Region的集合</li>
<li>跟踪各个Region里面垃圾的价值大小（回收空间和时间的经验值），根据允许的时间，优先回收价值大的，这也是Garbage-First名称由来，能建立可预测的停顿时间模型</li>
</ul>
<p><img src="http://o7b0ga5fo.bkt.clouddn.com/images/jvm/G1%E5%A0%86%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D.png" width="750" height="490" alt="G1堆空间分配" style="clear: both; display: block; margin:auto; "></p>
</li>
<li><p>问题一：Region并不是孤立的，可达性分析还是需要扫描整个Java堆？</p>
<ul>
<li>Region之间的对象引用以及其他收集器新老代的对象引用，都是通过Remembered Set来避免全局扫描的（通过GC Roots直接遍历不就可以了？不过这种也是全局遍历，如果遍历到老年代，收集的又是新生代，Remembered Set就可以发挥作用了，可以及时停止遍历。不知道我这个理解对不对？）</li>
<li>G1的每个Region都有一个Remembered Set，写操作的时候，虚拟机产生中断检查引用的对象是否处于不同的Region，如果是，便通过CardTable把相关引用信息记录到被引用对象所属的Remembered Set中</li>
</ul>
</li>
<li><p>G1的流程和CMS很相似</p>
<ul>
<li>G1中的一次年轻代GC：存活的对象被转移到一个/或多个存活区(survivor regions)。如果存活时间达到阀值，这部分对象就会被提升到老年代。此时会有一次Stop The World暂停，会计算出Eden大小和Survivor大小，给下一次年轻代GC使用，参考自<a href="http://blog.csdn.net/renfufei/article/details/41897113" target="_blank" rel="external">http://blog.csdn.net/renfufei/article/details/41897113</a></li>
</ul>
<p><img src="http://o7b0ga5fo.bkt.clouddn.com/images/jvm/G1%E6%94%B6%E9%9B%86%E5%99%A8%E8%BF%90%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.png" width="854" height="270" alt="G1收集器运行示意图" style="clear: both; display: block; margin:auto; "></p>
</li>
</ul>
</li>
</ul>
<h4 id="GC日志"><a href="#GC日志" class="headerlink" title="GC日志"></a>GC日志</h4><ul>
<li>GC和Full GC说明了这次垃圾收集的停顿类型，不是用来区分新生代和老年代的，如果有Full，说明发生了Stop The World</li>
<li>一般说的Minor GC表示新生代收集，Major GC表示老年代GC，和日志里面没关系</li>
</ul>
<h2 id="内存分配和回收策略"><a href="#内存分配和回收策略" class="headerlink" title="内存分配和回收策略"></a>内存分配和回收策略</h2><h3 id="对象优先在新生代分配"><a href="#对象优先在新生代分配" class="headerlink" title="对象优先在新生代分配"></a>对象优先在新生代分配</h3><ol>
<li>Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC</li>
<li>如果启用了本地线程分配缓冲，将按线程优先在TLAB上分配</li>
</ol>
<h3 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h3><ol>
<li>很长的字符串或数组</li>
<li>要尽量避免出现，容易在内存还有不少空间时就提前触发垃圾回收</li>
</ol>
<h3 id="长期存活对象进入老年代"><a href="#长期存活对象进入老年代" class="headerlink" title="长期存活对象进入老年代"></a>长期存活对象进入老年代</h3><ol>
<li>一般熬过一次Minor GC，年龄增加1，可通过参数设置晋升老年代的年龄阈值</li>
</ol>
<h3 id="动态对象年龄判断"><a href="#动态对象年龄判断" class="headerlink" title="动态对象年龄判断"></a>动态对象年龄判断</h3><ol>
<li>上面的年龄晋升并非绝对的，也有未到年龄晋升到老年代的情况</li>
<li>Survivor空间中相同年龄所有对象大小的总和超过一半时，年龄大于等于该年龄的对象就可以直接进入老年代</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/08/2017书单/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zjiash">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zjiash的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/08/2017书单/" itemprop="url">
                  2017书单
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-08T10:47:35+08:00">
                2017-02-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/读书/" itemprop="url" rel="index">
                    <span itemprop="name">读书</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/02/08/2017书单/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/02/08/2017书单/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="人类简史"><a href="#人类简史" class="headerlink" title="人类简史"></a>人类简史</h3><ol>
<li>认知革命正是历史从生物学中脱离而独立存在的起点。</li>
<li>身为人类，我们不可能脱离想象所构建出的秩序。每一次我们以为自己打破了监狱的高墙、迈向自由的前方，其实只是到了另一间更大的监狱，把活动范围稍稍加以扩大。</li>
</ol>
<h3 id="显微镜下的大明"><a href="#显微镜下的大明" class="headerlink" title="显微镜下的大明"></a>显微镜下的大明</h3><ol>
<li>管中窥豹，折射大明政治生态，类似《明朝那些事儿》</li>
</ol>
<h3 id="草房子"><a href="#草房子" class="headerlink" title="草房子"></a>草房子</h3><ol>
<li>关于成长的故事</li>
<li>儿童形象<ul>
<li>凸鹤：意识到缺陷并面对找回尊严</li>
<li>纸月：懵懂而纯洁的感情</li>
<li>杜小康：厄运中成长成熟</li>
<li>细马：自我选择和承担责任</li>
<li>桑桑：感悟生死和人生</li>
</ul>
</li>
<li>成人形象<ul>
<li>白雀 &amp; 蒋一轮：儿童眼中的爱情</li>
<li>秦大奶奶：质朴、善良、倔强的农民形象</li>
</ul>
</li>
</ol>
<h3 id="解忧杂货点"><a href="#解忧杂货点" class="headerlink" title="解忧杂货点"></a>解忧杂货点</h3><ol>
<li>温馨的故事和精巧的结构，不过感觉有点俗套了</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/06/《深入理解Java虚拟机》之内存布局/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zjiash">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zjiash的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/06/《深入理解Java虚拟机》之内存布局/" itemprop="url">
                  《深入理解Java虚拟机》之内存布局
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-06T18:19:39+08:00">
                2017-02-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/02/06/《深入理解Java虚拟机》之内存布局/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/02/06/《深入理解Java虚拟机》之内存布局/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近在看<a href="https://item.jd.com/11252778.html" target="_blank" rel="external">《深入理解Java虚拟机：JVM高级特性与最佳实践》</a>一书，准备做一些读书笔记总结一下，本文对Java的内存布局进行总结，后续会有更多该系列的文章。</p>
<h2 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h2><p>Java虚拟机在执行程序的时候，会将内存划分为若干个不同的数据区域，这些区域各有用途。</p>
<p><img src="http://o7b0ga5fo.bkt.clouddn.com/images/jvm/runtime_memory.png" width="500" height="500" alt="JVM运行时数据区" style="clear: both; display: block; margin:auto; "></p>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><ul>
<li>线程私有</li>
<li>当前线程执行到的位置</li>
<li>如果是Java方法，则为字节码指令地址；</li>
<li>如果是Native方法，为Undefined，唯一一个JVM没有规定任何OutOfMemoryError情况的区域。</li>
<li><font color="red">问题：Native方法是如何执行的？</font>

</li>
</ul>
<h3 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h3><ul>
<li>线程私有</li>
<li>Java方法执行的内存模型，每个方法创建一个Stack Frame</li>
<li>存储局部变量（编译器已知）、操作数栈、动态链接、方法出口等信息</li>
<li>栈溢出：<ul>
<li>如果线程请求的栈深度大于JVM所允许的最大深度，将抛出StackOverflowError异常</li>
<li>如果JVM在拓展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常（无法实验）</li>
</ul>
</li>
<li>栈容量可以限定，如果不能减少线程数或者更换64位虚拟机，就只能通过减少最大堆（总得栈容量剩的会多一些）和减少栈容量（每个线程的栈容量减小）来换取更多的线程</li>
</ul>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><ul>
<li>和虚拟机栈作用相似，用于执行Native方法</li>
</ul>
<h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><ul>
<li>所有线程共享的一块内存，存放对象示例，垃圾收集器关联的主要区域</li>
<li>逻辑上连续，物理上可以不连续</li>
<li>从垃圾回收的角度，可细分为：新生代和老年代</li>
</ul>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><ul>
<li>所有线程共享</li>
<li>存储已被JVM加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</li>
<li>HotSpot中通过永久代来实现方法区，其他虚拟机不存在永久带，虚拟机规范并无规定实现，HotSpot也在逐步放弃永久代的方法</li>
<li>这一块的垃圾回收效果并不理想，而且条件相当苛刻</li>
<li>方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常</li>
<li>进一步细分：运行时常量池、直接内存</li>
</ul>
<h2 id="HotSpot对象"><a href="#HotSpot对象" class="headerlink" title="HotSpot对象"></a>HotSpot对象</h2><h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><p>虚拟机遇到new指令时的行为？</p>
<ol>
<li>检查类名是否存在，该类是否被加载、 解析和初始化</li>
<li>分配内存（加载完成后即可确定内存大小），可以通过参数设置是否使用TLAB（本地线程分配缓冲）</li>
<li>初始化分配的内存空间（不包括对象头）为零值</li>
<li>设置对象头，例如这个对象是哪个类的实例、对应的类元数据信息、对象哈希码、对象的GC分代年龄等信息</li>
<li>构造方法</li>
</ol>
<h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><ul>
<li>分3块区域：对象头、实例数据、对齐填充</li>
<li>对象头：运行时数据、对象指针（并非所有虚拟机都有）</li>
<li>数组对象头还有记录数组长度的信息</li>
<li>实例数据：对象的有效信息或字段，字段存储顺序有分配策略：相同宽度的字段分配在一起，父类定义的变量出现在子类之前等</li>
<li>对齐填充：HotSpot要求对象起始地址必须是8字节的整数倍</li>
</ul>
<h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><ul>
<li>通过句柄<ul>
<li>句柄池，reference存储句柄地址，句柄中包含实例数据指针和类型数据指针</li>
<li>好处：对象被移动时修改句柄中的实例指针，reference本身不需要修改</li>
</ul>
</li>
<li>直接指针<ul>
<li>reference存储对象地址，对象将类型数据指针和实例数据存放在一起</li>
<li>好处：速度快，节省一次指针定位开销</li>
</ul>
</li>
<li>HotSpot采用直接指针的方式</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/06/关于一个赌博游戏的思考/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zjiash">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zjiash的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/06/关于一个赌博游戏的思考/" itemprop="url">
                  关于一个赌博游戏的思考
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-06T16:31:16+08:00">
                2017-02-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数学/" itemprop="url" rel="index">
                    <span itemprop="name">数学</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/02/06/关于一个赌博游戏的思考/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/02/06/关于一个赌博游戏的思考/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>春节回家见到的一种新的赌博方式（不得不说湖北人确实喜欢赌博），规则如下: </p>
<blockquote>
<p>一副扑克牌去掉大小王剩下52张，洗好牌后每次从牌堆里面按顺序取两张，计算两张牌的点数之和（J、Q、K分布表示11、12和13），猜单双。取出的牌使用完成后，不会马上进入牌堆，最后剩下的6张牌作废（避免有人记住最后剩下的牌），重新洗牌开始进行新的一轮活动。</p>
</blockquote>
<h2 id="动手实践"><a href="#动手实践" class="headerlink" title="动手实践"></a>动手实践</h2><p>了解规则之后，我直觉出现单和双的概率是不均等的，至少在牌局的末尾，是可以根据之前出现的牌的情况制定某种策略，提高猜中概率的。粗略一想，最终结果为单的情况包括：先单后双/先双后单，为双的情况包括：两个双/两个单。如果不考虑一副牌里面单数牌比较多（多4张）的情况，似乎可以认为这个活动出现单双的概率是均等的。但是，事实是否确实如此呢？</p>
<p>回来后写了个程序来模拟这个过程，想通过统计信息来观察概率是否均等，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">public class Gambling &#123;</span><br><span class="line">    private int num;        // 数字个数，一副完整的扑克牌num=13</span><br><span class="line">    private int multiple;   // 每种数字个数，一副完整的扑克牌有4种花色</span><br><span class="line">    private int left;       // 最后的几张牌废弃掉</span><br><span class="line">    private int start;      // 统计的起始位置</span><br><span class="line">    private List&lt;Integer&gt; cards;</span><br><span class="line"></span><br><span class="line">    public Gambling(int num, int multiple, int left, int start) &#123;</span><br><span class="line">        this.num = num;</span><br><span class="line">        this.multiple = multiple;</span><br><span class="line">        this.left = left;</span><br><span class="line">        this.start = start;</span><br><span class="line"></span><br><span class="line">        cards = new ArrayList&lt;Integer&gt;(num * multiple);</span><br><span class="line">        for (int i = 0; i &lt; num * multiple; i++) &#123;</span><br><span class="line">            cards.add(i / multiple + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        // System.out.println(&quot;arrays: &quot; + cards);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void sample(int times) &#123;</span><br><span class="line">        int totalOddNum = 0, totalEvenNum = 0;</span><br><span class="line">        for (int i = 0; i &lt; times; i++) &#123;</span><br><span class="line">            Random rnd = new Random(System.currentTimeMillis());</span><br><span class="line">            Collections.shuffle(cards, rnd);</span><br><span class="line"></span><br><span class="line">            int oddNum = 0, evenNum = 0;</span><br><span class="line">            for (int j = start; j &lt; (num * multiple - left) / 2; j++) &#123;</span><br><span class="line">                int value = cards.get(j * 2) + cards.get(j * 2 + 1);</span><br><span class="line">                if (value % 2 == 0) &#123;</span><br><span class="line">                    evenNum++;</span><br><span class="line">                    totalEvenNum++;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    oddNum++;</span><br><span class="line">                    totalOddNum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            int total = oddNum + evenNum;</span><br><span class="line">            if (i &lt; 5) &#123;</span><br><span class="line">                System.out.println(String.format(&quot;#%d: oddRate = %.3f, evenRate = %.3f&quot;,</span><br><span class="line">                        i, oddNum * 1.0 / total, evenNum * 1.0 / total));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int totalNum = totalOddNum + totalEvenNum;</span><br><span class="line">        System.out.println(String.format(&quot;total(%d): totalOddRate = %.5f, totalEvenRate = %.5f&quot;,</span><br><span class="line">                totalNum, totalOddNum * 1.0 / totalNum, totalEvenNum * 1.0 / totalNum));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Gambling gambling = new Gambling(13, 4, 6, 0);</span><br><span class="line">        gambling.sample(1000000);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行多次的结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">total(23000000): totalOddRate = 0.50739, totalEvenRate = 0.49261</span><br><span class="line">total(23000000): totalOddRate = 0.50695, totalEvenRate = 0.49305</span><br><span class="line">total(23000000): totalOddRate = 0.50724, totalEvenRate = 0.49276</span><br><span class="line">total(23000000): totalOddRate = 0.50651, totalEvenRate = 0.49349</span><br><span class="line">total(23000000): totalOddRate = 0.50629, totalEvenRate = 0.49371</span><br></pre></td></tr></table></figure>
<p>从结果中可以清楚的看到，出现单的概率比出现双的概率高1.4%，结果非常稳定。这说明游戏中出现单双的概率是不均等的，看到这样的结果，我第一反应是：会不会是单数牌多4张造成的？立即将程序中的num从13改成12，再次运行发现：<font color="red">出现单的概率比出现双的概率高了约2%</font>，比之前的结果更不均衡了。</p>
<h2 id="一点想法"><a href="#一点想法" class="headerlink" title="一点想法"></a>一点想法</h2><p>为什么会出现这样的情况？我回到数学论证上来考虑一个简单的例子：简化一副扑克，考虑只有4张牌的情况，2种花色和2种数字，排列的情况如下（不考虑花色的情况）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1、1、2、2</span><br><span class="line">1、2、1、2</span><br><span class="line">1、2、2、1</span><br><span class="line">2、1、1、2</span><br><span class="line">2、1、2、1</span><br><span class="line">2、2、1、1</span><br></pre></td></tr></table></figure>
<p>不考虑最后牌作废的情况，一共可以进行12次赌博活动，其中出现单的次数为8，出现双的次数为4，并不是直观上的机会均等。在这个极端的例子里面，最终结果出现双的条件相对比较苛刻，要求相邻的数字相同才行，第一个数字与第二个数字相同的概率为1/3，不同的概率为2/3，导致出现单的概率偏高。如果数字种数更多，情况应该会更好一些。通过运行下面的代码，验证了我们的想法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 1; i &lt; 7; i++) &#123;</span><br><span class="line">    Gambling gambling2 = new Gambling(i * 2, 2, 0, 0);</span><br><span class="line">    gambling2.sample(1000000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Results:</span><br><span class="line">total(2000000): totalOddRate = 0.66579, totalEvenRate = 0.33421</span><br><span class="line">total(4000000): totalOddRate = 0.55100, totalEvenRate = 0.44900</span><br><span class="line">total(6000000): totalOddRate = 0.54564, totalEvenRate = 0.45436</span><br><span class="line">total(8000000): totalOddRate = 0.53384, totalEvenRate = 0.46616</span><br><span class="line">total(10000000): totalOddRate = 0.52858, totalEvenRate = 0.47142</span><br><span class="line">total(12000000): totalOddRate = 0.51977, totalEvenRate = 0.48023</span><br></pre></td></tr></table></figure>
<p>上面的程序避免了单数牌和双数牌数目不一致的情况，更多的牌引入了更多的配对可能性，使得结果趋于均衡。如果考虑正常扑克的行为，会发现当单数牌多一种时，会导致出现双的概率增大。换句话说，13种牌单双概率的差异要比12和14种牌都要小。</p>
<p>事实上按照排列组合的分析，应该是可以得到准确的结果，一个直观的解释是：奇偶性不同的牌组合才能得到单数的结果，当单数牌比较多的时候，奇偶性不同的牌组合之后，多出的牌结果肯定是双，这一事实导致了单双概率差距缩小，使得整个游戏更为公平。对于单数牌和双数牌相同的情况，似乎也可以用上面的简化case来解释。</p>
<h2 id="赢钱策略"><a href="#赢钱策略" class="headerlink" title="赢钱策略"></a>赢钱策略</h2><p>根据上面的分析发现：出现单的概率要高，那押单是个不错的选择。如果根据一副牌已经出现的结果，来制定后面的押注策略，感觉应该还有更好的赢钱策略。这个留到回头在研究。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/06/15/Go语言圣经读后感/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zjiash">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zjiash的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/15/Go语言圣经读后感/" itemprop="url">
                  Go语言圣经读后感
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-06-15T12:07:48+08:00">
                2016-06-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/06/15/Go语言圣经读后感/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/15/Go语言圣经读后感/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近读了下<a href="http://www.gopl.io/" target="_blank" rel="external">《The Go Programming Language》</a>，网上没有找到完整的英文版，可以找到翻译的<a href="https://docs.ruanjiadeng.com/gopl-zh/index.html" target="_blank" rel="external">中文版</a>，中文版翻译得比较一般，有较多的打印和翻译错误。由于之前对Go语言有一定的了解，因此中文版看起来也没什么问题。个人觉得该书算是不错的Go语言入门书了，不管是从行文方式（用例实用且详细，同时由浅入深）还是阐述深度等方面来看，都比之前看的那本要强一些，本人从中获益良多，因此行文总结一下。</p>
<h2 id="Programming-Language"><a href="#Programming-Language" class="headerlink" title="Programming Language"></a>Programming Language</h2><h3 id="无类型常量"><a href="#无类型常量" class="headerlink" title="无类型常量"></a>无类型常量</h3><p>许多常量并没有一个明确的基础类型，编译器为这些没有明确基础类型的数字常量提供比基础类型更高精度的算术运算，你可以认为至少有256bit的运算精度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const a = 1208925819614629174706176</span><br><span class="line">fmt.Println(a / 1180591620717411303424)     // ouput 1024</span><br><span class="line">// fmt.Println(a)   // error: constant 1208925819614629174706176 overflows int</span><br><span class="line"></span><br><span class="line">var f float64 = 3 + 0i</span><br><span class="line">fmt.Println(f)  // output 3</span><br></pre></td></tr></table></figure>
<p>只有常量可以是无类型的。当一个无类型的常量被赋值给一个变量的时候，无类型的常量将会被隐式转换为对应的类型，如果转换合法的话。</p>
<h3 id="包的初始化"><a href="#包的初始化" class="headerlink" title="包的初始化"></a>包的初始化</h3><ol>
<li>包的初始化首先是解决包级变量的依赖顺序，然后安照包级变量声明出现的顺序依次初始化。</li>
<li>每个包在解决依赖的前提下，以导入声明的顺序初始化，每个包只会被初始化一次。因此，如果一个p包导入了q包，那么在p包初始化的时候可以认为q包必然已经初始化过了。初始化工作是自下而上进行的，main包最后被初始化。以这种方式，可以确保在main函数执行之前，所有依然的包都已经完成初始化工作了。</li>
</ol>
<h2 id="Programming-Pitfall"><a href="#Programming-Pitfall" class="headerlink" title="Programming Pitfall"></a>Programming Pitfall</h2><h3 id="迭代变量"><a href="#迭代变量" class="headerlink" title="迭代变量"></a>迭代变量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">错误方式：可能会一直输出最后一个元素</span><br><span class="line">for val := range values &#123;</span><br><span class="line">    go func() &#123;</span><br><span class="line">        fmt.Println(val)</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">正确方式：</span><br><span class="line">for val := range values &#123;</span><br><span class="line">    go func(val interface&#123;&#125;) &#123;</span><br><span class="line">        fmt.Println(val)</span><br><span class="line">    &#125;(val)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="内存同步"><a href="#内存同步" class="headerlink" title="内存同步"></a>内存同步</h3><p>下面的代码段可能输出如下结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x:0 y:0</span><br><span class="line">y:0 x:0</span><br></pre></td></tr></table></figure>
<p>解释：在一个独立的goroutine中，每一个语句的执行顺序是可以被保证的；也就是说goroutine是顺序连贯的。但是在不使用channel且不使用mutex这样的显式同步操作时，我们就没法保证事件在不同的goroutine中看到的执行顺序是一致的了。尽管goroutine A中一定需要观察到x=1执行成功之后才会去读取y，但它没法确保自己观察得到goroutine B中对y的写入，所以A还可能会打印出y的一个旧版的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var x, y int</span><br><span class="line"></span><br><span class="line">go func() &#123;</span><br><span class="line">    x = 1 // A1</span><br><span class="line">    fmt.Print(&quot;y:&quot;, y, &quot; &quot;) // A2</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">go func() &#123;</span><br><span class="line">    y = 1                   // B1</span><br><span class="line">    fmt.Print(&quot;x:&quot;, x, &quot; &quot;) // B2</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>
<h2 id="Programming-Pattern"><a href="#Programming-Pattern" class="headerlink" title="Programming Pattern"></a>Programming Pattern</h2><h3 id="计算函数运行时间"><a href="#计算函数运行时间" class="headerlink" title="计算函数运行时间"></a>计算函数运行时间</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func bigSlowOperation() &#123;</span><br><span class="line">    defer trace(&quot;bigSlowOperation&quot;)() // don&apos;t forget the extra parentheses</span><br><span class="line">    // ...lots of work…</span><br><span class="line">    time.Sleep(10 * time.Second) // simulate slow operation by sleeping</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func trace(msg string) func() &#123;</span><br><span class="line">    start := time.Now()</span><br><span class="line">    log.Printf(&quot;enter %s&quot;, msg)</span><br><span class="line">    return func() &#123; </span><br><span class="line">        log.Printf(&quot;exit %s (%s)&quot;, msg,time.Since(start)) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用锁进行并发"><a href="#使用锁进行并发" class="headerlink" title="使用锁进行并发"></a>使用锁进行并发</h3><p>传统的并发做法，使用锁来避免竞争条件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var (</span><br><span class="line">    mu      sync.Mutex // guards balance</span><br><span class="line">    balance int</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func Deposit(amount int) &#123;</span><br><span class="line">    mu.Lock()</span><br><span class="line">    defer mu.Unlock()</span><br><span class="line">    balance = balance + amount</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func Balance() int &#123;</span><br><span class="line">    mu.Lock()</span><br><span class="line">    defer mu.Unlock()</span><br><span class="line">    return balance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用通信进行并发"><a href="#使用通信进行并发" class="headerlink" title="使用通信进行并发"></a>使用通信进行并发</h3><p>Go推荐的做法：不要使用共享数据来通信；使用通信来共享数据。一个提供对指定变量通过cahnnel来请求的goroutine叫做这个变量的监控(monitor)goroutine，只有一个goroutine能够访问变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var deposits = make(chan int) // send amount to deposit</span><br><span class="line">var balances = make(chan int) // receive balance</span><br><span class="line"></span><br><span class="line">func Deposit(amount int) &#123; deposits &lt;- amount &#125;</span><br><span class="line">func Balance() int       &#123; return &lt;-balances &#125;</span><br><span class="line"></span><br><span class="line">func teller() &#123;</span><br><span class="line">    var balance int // balance is confined to teller goroutine</span><br><span class="line">    for &#123;</span><br><span class="line">        select &#123;</span><br><span class="line">        case amount := &lt;-deposits:</span><br><span class="line">            balance += amount</span><br><span class="line">        case balances &lt;- balance:</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func init() &#123;</span><br><span class="line">    go teller() // start the monitor goroutine</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="广播机制"><a href="#广播机制" class="headerlink" title="广播机制"></a>广播机制</h3><p>关闭同步channel可以让所有等待该channel的goroutine都收到信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">type entry struct &#123;</span><br><span class="line">    res   result</span><br><span class="line">    ready chan struct&#123;&#125; // closed when res is ready</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func New(f Func) *Memo &#123;</span><br><span class="line">    return &amp;Memo&#123;f: f, cache: make(map[string]*entry)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Memo struct &#123;</span><br><span class="line">    f     Func</span><br><span class="line">    mu    sync.Mutex // guards cache</span><br><span class="line">    cache map[string]*entry</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (memo *Memo) Get(key string) (value interface&#123;&#125;, err error) &#123;</span><br><span class="line">    memo.mu.Lock()</span><br><span class="line">    e := memo.cache[key]</span><br><span class="line">    if e == nil &#123;</span><br><span class="line">        // This is the first request for this key.</span><br><span class="line">        // This goroutine becomes responsible for computing</span><br><span class="line">        // the value and broadcasting the ready condition.</span><br><span class="line">        e = &amp;entry&#123;ready: make(chan struct&#123;&#125;)&#125;</span><br><span class="line">        memo.cache[key] = e</span><br><span class="line">        memo.mu.Unlock()</span><br><span class="line"></span><br><span class="line">        e.res.value, e.res.err = memo.f(key)</span><br><span class="line"></span><br><span class="line">        close(e.ready) // broadcast ready condition</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // This is a repeat request for this key.</span><br><span class="line">        memo.mu.Unlock()</span><br><span class="line"></span><br><span class="line">        &lt;-e.ready // wait for ready condition</span><br><span class="line">    &#125;</span><br><span class="line">    return e.res.value, e.res.err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/05/16/红黑树/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zjiash">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zjiash的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/16/红黑树/" itemprop="url">
                  红黑树
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-05-16T10:24:31+08:00">
                2016-05-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/05/16/红黑树/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/16/红黑树/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近在复习数据结构，打算用Go语言实现一下常用的数据结构，所以就有了这篇文章，维基百科上关于红黑树的基本描述如下：</p>
<blockquote>
<p>红黑树（英语：Red–black tree）是一种自平衡二叉查找树，可以在O(log n)时间内做查找，插入和删除。</p>
</blockquote>
<h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><p>红黑树是每个节点都带有颜色属性的二叉查找树，颜色为红色或黑色。在二叉查找树强制一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求：   </p>
<ol>
<li>节点是红色或黑色。</li>
<li>根是黑色。</li>
<li>所有叶子都是黑色（叶子是NIL节点，这个特性在插入里面用不到，在节点删除里面起作用）。</li>
<li>每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）</li>
<li>从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。</li>
</ol>
<p><img src="http://o7b0ga5fo.bkt.clouddn.com/images/rbtree/rbtree.png" width="500" height="300" alt="红黑树示例图" style="clear: both; display: block; margin:auto; "></p>
<p>这些约束确保了红黑树的关键特性：从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。结果是这个树大致上是平衡的。因为操作比如插入、删除和查找某个值的最坏情况时间都要求与树的高度成比例，这个在高度上的理论上限允许红黑树在最坏情况下都是高效的，而不同于普通的二叉查找树。</p>
<p>要知道为什么这些性质确保了这个结果，注意到性质4导致了路径不能有两个毗连的红色节点就足够了。最短的可能路径都是黑色节点，最长的可能路径有交替的红色和黑色节点。因为根据性质5所有最长的路径都有相同数目的黑色节点，这就表明了没有路径能多于任何其他路径的两倍长。</p>
<h2 id="实现准备"><a href="#实现准备" class="headerlink" title="实现准备"></a>实现准备</h2><p><strong>基本定义</strong>，包括节点和树的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line">    RED   bool = true</span><br><span class="line">    BLACK bool = false</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type RBNode struct &#123;</span><br><span class="line">    value               int64</span><br><span class="line">    color               bool</span><br><span class="line">    left, right, parent *RBNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type RBTree struct &#123;</span><br><span class="line">    root *RBNode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>基本操作</strong>，包括左旋和右旋：</p>
<p><img src="http://o7b0ga5fo.bkt.clouddn.com/images/rbtree/left_rotate.jpg" width="400" height="150" alt="左旋示例图" style="clear: both; display: block; margin:auto; "></p>
<p><strong>左旋</strong>：以P为轴心左旋，左旋必须要有右子节点，右子节点N成为P的父亲，N的左子节点成为P的右子节点</p>
<p><img src="http://o7b0ga5fo.bkt.clouddn.com/images/rbtree/right_rotate.jpg" width="400" height="160" alt="右旋示例图" style="clear: both; display: block; margin:auto; "></p>
<p><strong>右旋</strong>：以P为轴心右旋，右旋必须要有左子节点，左子节点N成为P的父亲，N的右子节点成为P的左子节点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// 只贴左旋的代码，右旋完全类似</span><br><span class="line">// 注意：如果树的root可能发生变化，需要返回旋转后的父亲节点</span><br><span class="line">func (self *RBNode) leftRotate() (*RBNode, error) &#123;</span><br><span class="line">    var root *RBNode</span><br><span class="line">    if self == nil &#123;</span><br><span class="line">        return root, nil</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    parent := self.parent</span><br><span class="line">    rightChild := self.right</span><br><span class="line">    if rightChild == nil &#123;</span><br><span class="line">        return root, errors.New(&quot;left rotate node without right child&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // rotate</span><br><span class="line">    rightChildLeft := rightChild.left</span><br><span class="line">    rightChild.left = self</span><br><span class="line">    self.parent = rightChild</span><br><span class="line">    self.right = rightChildLeft</span><br><span class="line">    if rightChildLeft != nil &#123;</span><br><span class="line">        rightChildLeft.parent = self</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if parent == nil &#123;</span><br><span class="line">        root = rightChild</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 判断左右</span><br><span class="line">        if parent.left == self &#123;</span><br><span class="line">            parent.left = rightChild</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            parent.right = rightChild</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rightChild.parent = parent</span><br><span class="line"></span><br><span class="line">    return root, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>二叉搜索树插入的节点一定是叶子节点，因此考虑性质5，则插入节点只能是红色的。首先实现二叉搜索树的插入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 插入，二叉搜索树的插入方法，插入成功之后进行调整</span><br><span class="line">func (self *RBTree) insertNode(node *RBNode, data int64) &#123;</span><br><span class="line">    if node.value &gt;= data &#123;</span><br><span class="line">        if node.left == nil &#123;</span><br><span class="line">            tmp := NewRBNode(data)</span><br><span class="line">            tmp.parent = node</span><br><span class="line">            node.left = tmp</span><br><span class="line">            self.adjust(tmp)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            self.insertNode(node.left, data)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if node.right == nil &#123;</span><br><span class="line">            tmp := NewRBNode(data)</span><br><span class="line">            tmp.parent = node</span><br><span class="line">            node.right = tmp</span><br><span class="line">            self.adjust(tmp)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            self.insertNode(node.right, data)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>红黑树的调整分5种情况，实际上是7种情况，不过有两种情况是对称的，有的情况需要递归到其他情况：</p>
<p><strong>情形1</strong>: 新节点N位于树的根上，没有父节点</p>
<ul>
<li>在这种情形下（其他情况递归也可能到这种情况），我们把它重绘为黑色以满足性质2。因为它在每个路径上对黑节点数目增加一，性质5符合。</li>
</ul>
<p><strong>情形2</strong>: 新节点的父节点P是黑色</p>
<ul>
<li>性质4没有失效（新节点是红色的）。</li>
<li>在这种情形下，树仍是有效的。性质5也未受到威胁，尽管新节点N有两个黑色叶子子节点；但由于新节点N是红色，通过它的每个子节点的路径就都有同通过它所取代的黑色的叶子的路径同样数目的黑色节点，所以依然满足这个性质。</li>
</ul>
<p><strong>情形3</strong>: 如果父节点P和叔父节点U二者都是红色</p>
<ul>
<li>此时新插入节点N做为P的左子节点或右子节点都属于情形3，这里右图仅显示N做为P左子的情形，则我们可以将它们两个重绘为黑色并重绘祖父节点G为红色（用来保持性质5）。</li>
<li>现在我们的新节点N有了一个黑色的父节点P。因为通过父节点P或叔父节点U的任何路径都必定通过祖父节点G，在这些路径上的黑节点数目没有改变。</li>
<li>但是，红色的祖父节点G可能是根节点，这就违反了性质2，也有可能祖父节点G的父节点是红色的，这就违反了性质4。为了解决这个问题，我们在祖父节点G上递归地进行情形1的整个过程。（把G当成是新加入的节点进行各种情形的检查）</li>
</ul>
<p><img src="http://o7b0ga5fo.bkt.clouddn.com/images/rbtree/rb_tree_insert_case_3.png" width="400" height="150" alt="情形3" style="clear: both; display: block; margin:auto; "></p>
<p><strong>情形4</strong>: 父节点P是红色而叔父节点U是黑色或缺少，并且新节点N是其父节点P的右子节点而父节点P又是其父节点的左子节点，简称为“左右”</p>
<ul>
<li>在这种情形下，我们进行一次左旋转调换新节点和其父节点的角色;</li>
<li>接着，我们按情形5处理以前的父节点P以解决仍然失效的性质4。注意这个改变会导致某些路径通过它们以前不通过的新节点N（比如图中1号叶子节点）或不通过节点P（比如图中3号叶子节点），但由于这两个节点都是红色的，所以性质5仍有效。</li>
</ul>
<p><img src="http://o7b0ga5fo.bkt.clouddn.com/images/rbtree/rb_tree_insert_case_4.png" width="400" height="150" alt="情形4" style="clear: both; display: block; margin:auto; "></p>
<p><strong>情形5</strong>: 父节点P是红色而叔父节点U是黑色或缺少，新节点N是其父节点的左子节点，而父节点P又是其父节点G的左子节点。简称为“左左”</p>
<ul>
<li>在这种情形下，我们进行针对祖父节点G的一次右旋转；在旋转产生的树中，以前的父节点P现在是新节点N和以前的祖父节点G的父节点。我们知道以前的祖父节点G是黑色，否则父节点P就不可能是红色（如果P和G都是红色就违反了性质4，所以G必须是黑色）。我们切换以前的父节点P和祖父节点G的颜色，结果的树满足性质4。性质5也仍然保持满足，因为通过这三个节点中任何一个的所有路径以前都通过祖父节点G，现在它们都通过以前的父节点P。在各自的情形下，这都是三个节点中唯一的黑色节点。</li>
</ul>
<p><img src="http://o7b0ga5fo.bkt.clouddn.com/images/rbtree/rb_tree_insert_case_5.png" width="400" height="150" alt="情形5" style="clear: both; display: block; margin:auto; "></p>
<p><strong>调整代码如下</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">func (self *RBTree) adjust(node *RBNode) &#123;</span><br><span class="line">    parent := node.parent</span><br><span class="line">    if parent == nil &#123;</span><br><span class="line">        // 情形1：（递归后）新节点位于树的根上</span><br><span class="line">        node.color = BLACK</span><br><span class="line">        self.root = node</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if parent.color == BLACK &#123;</span><br><span class="line">        // 情形2：新节点的父节点P是黑色，性质不失效</span><br><span class="line">        return</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        uncle := node.getUncle()</span><br><span class="line">        grandParent := node.getGrandParent()</span><br><span class="line">        if uncle != nil &amp;&amp; uncle.color == RED &#123;</span><br><span class="line">            // 情形3：父节点和叔父节点均为红色</span><br><span class="line">            // 处理：父节点和叔父节点转为黑色，祖父节点改成红色，递归处理祖父节点</span><br><span class="line">            node.parent.color = BLACK</span><br><span class="line">            uncle.color = BLACK</span><br><span class="line">            grandParent.color = RED</span><br><span class="line">            self.adjust(grandParent)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            isLeft := (node == parent.left)</span><br><span class="line">            isParentLeft := (node.parent == grandParent.left)</span><br><span class="line">            if isLeft &amp;&amp; isParentLeft &#123;</span><br><span class="line">                // 情形5：左左</span><br><span class="line">                // 处理：祖父节点右旋</span><br><span class="line">                node.parent.color = BLACK</span><br><span class="line">                grandParent.color = RED</span><br><span class="line">                self.rotateRight(grandParent)</span><br><span class="line">            &#125; else if !isLeft &amp;&amp; isParentLeft &#123;</span><br><span class="line">                // 情形4：左右</span><br><span class="line">                // 处理：父节点左旋，变成情形4左左</span><br><span class="line">                self.rotateLeft(node.parent)</span><br><span class="line">                // 现在的node.parent表示原来的祖父节点</span><br><span class="line">                self.rotateRight(node.parent)</span><br><span class="line"></span><br><span class="line">                node.color = BLACK</span><br><span class="line">                node.left.color = RED</span><br><span class="line">                node.right.color = RED</span><br><span class="line">            &#125; else if isLeft &amp;&amp; !isParentLeft &#123;</span><br><span class="line">                // 情形4对称：右左</span><br><span class="line">                self.rotateRight(node.parent)</span><br><span class="line">                self.rotateLeft(node.parent)</span><br><span class="line"></span><br><span class="line">                node.color = BLACK</span><br><span class="line">                node.left.color = RED</span><br><span class="line">                node.right.color = RED</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 情形5对称：右右</span><br><span class="line">                node.parent.color = BLACK</span><br><span class="line">                grandParent.color = RED</span><br><span class="line">                self.rotateLeft(grandParent)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>暂时没有实现删除，后续有时间会加上</p>
<p>参考文献：</p>
<ul>
<li><a href="https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91" target="_blank" rel="external">维基百科</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/04/01/Http-Header详解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zjiash">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zjiash的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/01/Http-Header详解/" itemprop="url">
                  Http Header详解
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-04-01T11:07:10+08:00">
                2016-04-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/04/01/Http-Header详解/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/04/01/Http-Header详解/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Http-Request"><a href="#Http-Request" class="headerlink" title="Http Request"></a>Http Request</h1><h2 id="Accept类"><a href="#Accept类" class="headerlink" title="Accept类"></a>Accept类</h2><ul>
<li>Accept：客户端接受什么样的类型<ul>
<li><code>*/*</code>表示任何类型，<code>text/*</code>表示text类型下的所有子类型，<code>text/plain</code>和<code>text/html</code>表示具体类型</li>
</ul>
</li>
<li>Accept-Charset： 客户端申明自己接收的字符集 </li>
<li>Accept-Encoding： 客户端申明自己接收的编码方法<ul>
<li>通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate） </li>
</ul>
</li>
<li>Accept-Language：客户端申明自己接收的语言 <ul>
<li>语言跟字符集的区别：中文zh是语言，中文有多种字符集，比如big5，gb2312，gbk等等</li>
</ul>
</li>
</ul>
<h2 id="Cache相关"><a href="#Cache相关" class="headerlink" title="Cache相关"></a>Cache相关</h2><ul>
<li>Cache-Control：<ul>
<li>no-cache：不要缓存的实体，要求现在从服务器去取</li>
<li>max-age：只接受Age值小于max-age值，并且没有过期的对象</li>
<li>max-stale：可以接受过去的对象，但是过期时间必须小于max-stale值 </li>
<li>min-fresh：接受其新鲜生命期大于其当前Age跟min-fresh值之和的缓存对象</li>
</ul>
</li>
<li>Pramga：<ul>
<li>主要使用<code>Pramga: no-cache</code>，相当于<code>Cache-Control：no-cache</code></li>
</ul>
</li>
</ul>
<h2 id="Conditional类"><a href="#Conditional类" class="headerlink" title="Conditional类"></a>Conditional类</h2><ul>
<li>If-Modified-Since和If-None-Match：<ul>
<li>两者均表示允许在对应的内容未被修改的情况下返回304未修改，用于validate cache with server</li>
<li>区别在于前者配合Last-Modified使用，后者配合ETag使用</li>
</ul>
</li>
<li>If-Unmodified-Since和If-Match<ul>
<li>两者均表示仅当该实体自某个特定时间已来未被修改的情况下，才进行对应的操作。主要用于更新操作，比如像PUT这样的方法，仅当从用户上次更新某个资源以来，该资源未被修改的情况下，才更新该资源</li>
<li>区别在于前者配合Last-Modified使用，后者配合ETag使用</li>
</ul>
</li>
</ul>
<h2 id="其他重要的"><a href="#其他重要的" class="headerlink" title="其他重要的"></a>其他重要的</h2><ul>
<li>Connection：<ul>
<li>close：告诉WEB服务器或者代理服务器，在完成本次请求的响应后，断开连接，不要等待本次连接的后续请求了</li>
<li>keepalive：告诉WEB服务器或者代理服务器，在完成本次请求的响应后，保持连接，等待本次连接的后续请求 </li>
</ul>
</li>
<li>User-Agent：浏览器表明自己的身份</li>
<li>Upgrade：要求服务器升级到另一个协议，WebSocket会使用 </li>
</ul>
<h1 id="Http-Response"><a href="#Http-Response" class="headerlink" title="Http Response"></a>Http Response</h1><h2 id="Content类"><a href="#Content类" class="headerlink" title="Content类"></a>Content类</h2><ul>
<li>Content-Encoding：服务器表明自己使用了什么压缩方法（gzip，deflate）压缩响应中的对象。</li>
<li>Content-Language：服务器告诉浏览器自己响应的对象的语言。</li>
<li>Content-Length： 服务器告诉浏览器自己响应的对象的长度。</li>
<li>Content-Range： 服务器表明该响应包含的部分对象为整个对象的哪个部分。</li>
<li>Content-Type： 服务器告诉浏览器自己响应的对象的类型。例如：Content-Type：application/xml</li>
<li>Last-Modified：服务器认为对象的最后修改时间，比如文件的最后修改时间，动态页面的最后产生时间等等。</li>
<li>ETag：对象的标志值，就一个对象而言，比如一个html文件，如果被修改了，其 Etag也会别修改，所以ETag的作用跟Last-Modified的作用差不多，主要供服务器判断一个对象是否改变了。</li>
<li>Transfer-Encoding：服务器表明自己对本响应消息体（不是消息体里面的对象）作了怎样的编码，比如是否分块（chunked），chunk编码将数据分成一块一块的发生。Chunked编码将使用若干个Chunk串连而成，由一个标明长度为0的chunk标示结束。</li>
</ul>
<h2 id="Cache相关-1"><a href="#Cache相关-1" class="headerlink" title="Cache相关"></a>Cache相关</h2><ul>
<li>Cache-Control：<ul>
<li>public：可以用Cached内容回应任何用户</li>
<li>private：只能用缓存内容回应先前请求该内容的那个用户</li>
<li>no-cache：可以缓存，但是只有在跟服务器验证了其有效后，才能返回给客户端 </li>
<li>no-store：不允许缓存</li>
<li>max-age：本响应包含的对象的过期时间</li>
</ul>
</li>
<li>Vary：服务器用该头部的内容告诉Cache服务器（代理服务器或者网关），在什么条件下才能用本响应所返回的对象响应后续的请求。<ul>
<li>解释：源服务器在接到第一个请求消息时，其响应消息的头部为：Content-Encoding: gzip; Vary: Content-Encoding那么Cache服务器会分析后续请求消息的头部，检查其Accept-Encoding，是否跟先前响应的Vary头部值一致，即是否使用相同的内容编码方法，这样就可以防止Cache服务器用自己Cache里面压缩后的实体响应给不具备解压能力的浏览器。</li>
</ul>
</li>
</ul>
<h2 id="其他重要的-1"><a href="#其他重要的-1" class="headerlink" title="其他重要的"></a>其他重要的</h2><ul>
<li>Connection：针对该连接所预期的选项，服务器应该可以修改</li>
<li>Via： 列出从客户端到OCS或者相反方向的响应经过了哪些代理服务器，他们用什么协议（和版本）发送的请求。<ul>
<li>解释：当客户端请求到达第一个代理服务器时，该服务器会在自己发出的请求里面添加Via头部，并填上自己的相关信息，当下一个代理服务器收到第一个代理服务器的请求时，会在自己发出的请求里面复制前一个代理服务器的请求的Via头部，并把自己的相关信息加到后面，以此类推，当OCS收到最后一个代理服务器的请求时，检查Via头部，就知道该请求所经过的路由。</li>
</ul>
</li>
<li>Server: 服务器表明自己是什么软件及版本等信息</li>
</ul>
<p>参考文献：</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/List_of_HTTP_header_fields" target="_blank" rel="external">List_of_HTTP_header_fields</a></li>
<li><a href="http://www.cnblogs.com/skynet/archive/2010/12/11/1903347.html" target="_blank" rel="external">HTTP Keep-Alive模式</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="zjiash" />
          <p class="site-author-name" itemprop="name">zjiash</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">22</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">13</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/zjiash" target="_blank" title="github">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  github
                </a>
              </span>
            
          
        </div>

        
        
          <div class="cc-license motion-element" itemprop="license">
            <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" target="_blank">
              <img src="/images/cc-by-nc-sa.svg" alt="Creative Commons" />
            </a>
          </div>
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zjiash</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 访问人数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> 总访问量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>


        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"zjiash"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  
















  





  

  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
